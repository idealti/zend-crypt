{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-crypt Zend\\Crypt provides support of some cryptographic tools. Some of the available features are: encrypt-then-authenticate using symmetric ciphers (the authentication step is provided using HMAC); encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm); encrypt/decrypt using hybrid mode (OpenPGP like); generate digital sign using public key algorithm (e.g. RSA algorithm); key exchange using the Diffie-Hellman method; key derivation function (e.g. using PBKDF2 algorithm); secure password hash (e.g. using Bcrypt algorithm); generate Hash values; generate HMAC values; The main scope of this component is to offer an easy and secure way to protect and authenticate sensitive data in PHP. File issues at https://github.com/zendframework/zend-crypt/issues Documentation is at https://docs.zendframework.com/zend-crypt","title":"zend-crypt"},{"location":"#zend-crypt","text":"Zend\\Crypt provides support of some cryptographic tools. Some of the available features are: encrypt-then-authenticate using symmetric ciphers (the authentication step is provided using HMAC); encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm); encrypt/decrypt using hybrid mode (OpenPGP like); generate digital sign using public key algorithm (e.g. RSA algorithm); key exchange using the Diffie-Hellman method; key derivation function (e.g. using PBKDF2 algorithm); secure password hash (e.g. using Bcrypt algorithm); generate Hash values; generate HMAC values; The main scope of this component is to offer an easy and secure way to protect and authenticate sensitive data in PHP. File issues at https://github.com/zendframework/zend-crypt/issues Documentation is at https://docs.zendframework.com/zend-crypt","title":"zend-crypt"},{"location":"block-cipher/","text":"Encrypt/decrypt using block ciphers Zend\\Crypt\\BlockCipher implements encrypt-then-authenticate mode using HMAC to provide authentication. The symmetric cipher can be chosen with a specific adapter that implements Zend\\Crypt\\Symmetric\\SymmetricInterface . We support the symmmetric encryption algorithms offered by OpenSSL and Mcrypt extensions. In the following code, we detail an example of using the BlockCipher class to encrypt-then-authenticate a string using the AES-256 block cipher and the HMAC algorithm (using the SHA-256 hash function). Mcrypt The Mcrypt extension is based on the libmcrypt library. Unfortunately, at the time of writing, the project is dead, having been unmaintained for around 8 years, with the last release (version 2.5.8) having occurred in February 2007. Starting with PHP 7.1, the Mcrypt extension will be considered deprecated . For these reasons, we strongly suggest using only the Openssl adapter . Starting with zend-crypt 3.0, the Openssl adapter is the default (for example, by Zend\\Crypt\\FileCipher ), and all examples now only demonstrate that adapter. use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory('openssl', array('algo' => 'aes')); $blockCipher->setKey('encryption key'); $result = $blockCipher->encrypt('this is a secret message'); echo \"Encrypted text: $result\\n\"; The BlockCipher instance is initialized using a factory method with the name of the cipher adapter to use (e.g., openssl ) and the parameters to pass to the adapter (the AES algorithm). In order to encrypt a string, we need to specify an encryption key, which we do via the setKey() method. Encryption is performed with the encrypt() method. The output of encryption is a string, encoded in Base64 (default), containing the HMAC value, the IV vector, and the encrypted text. The encryption mode used is CBC (with a random IV by default), with the default HMAC hash algorithm of SHA256. The Openssl adapter encrypts using the PKCS#7 padding mechanism by default. You can specify a different padding method using a special adapter ( Zend\\Crypt\\Symmetric\\Padding ). The encryption and authentication keys used by BlockCipher are generated with the PBKDF2 algorithm, used as the key derivation function from the user's key specified using the setKey() method. Key size BlockCipher always attempts to use the longest key size for the specified cipher. For instance, for the AES algorithm it uses 256 bits, and for the Blowfish algorithm it uses 448 bits. You can change all the default settings by passing the values to the factory parameters. For instance, if you want to use the Blowfish algorithm, with the CFB mode and the HMAC SHA512 hash function, initialize the class as follows: use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory( 'openssl', [ 'algo' => 'blowfish', 'mode' => 'cfb', 'hash' => 'sha512' ] ); Recommendation If you are not familiar with symmetric encryption techniques, we strongly suggest using the default values of the BlockCipher class. The default values are: AES algorithm, CBC mode, HMAC with SHA256, PKCS#7 padding. To decrypt a string we can use the decrypt() method. In order to successfully decrypt a string, we must configure the BlockCipher with the same parameters used during encryption. We can also initialize the BlockCipher manually without using the factory method; we can inject the symmetric cipher adapter directly via the constructor. For instance, we can rewrite the previous example as follows: use Zend\\Crypt\\BlockCipher; use Zend\\Crypt\\Symmetric\\Openssl; $blockCipher = new BlockCipher(new Openssl(['algo' => 'aes'])); $blockCipher->setKey('encryption key'); $result = $blockCipher->encrypt('this is a secret message'); echo \"Encrypted text: $result \\n\"; Using GCM or CCM mode from PHP 7.1+ If you are using PHP 7.1+ you can choose the GCM or CCM mode for authenticated encryption with OpenSSL. These modes provide authenticated encryption by itself, without the usage of HMAC as described in the previous section. GCM is Galois/Counter Mode and CCM is Counter with CBC-MAC . For more information on the usage of this encryption modes in PHP we suggest to read this blog post . If you want to use the GCM or CCM mode with BlockCipher you can just specify the mode in the factory. For instance, the following is an example of aes-256-gcm encryption with OpenSSL: use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory( 'openssl', [ 'algo' => 'aes', 'mode' => 'gcm' ] ); And below is an example demonstrating the factory for aes-256-ccm algorithm: use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory( 'openssl', [ 'algo' => 'aes', 'mode' => 'ccm' ] ); Recommendation GCM mode is about 3x faster than CCM , we recommend using GCM unless you have requirements that dictate CCM.","title":"Block Ciphers"},{"location":"block-cipher/#encryptdecrypt-using-block-ciphers","text":"Zend\\Crypt\\BlockCipher implements encrypt-then-authenticate mode using HMAC to provide authentication. The symmetric cipher can be chosen with a specific adapter that implements Zend\\Crypt\\Symmetric\\SymmetricInterface . We support the symmmetric encryption algorithms offered by OpenSSL and Mcrypt extensions. In the following code, we detail an example of using the BlockCipher class to encrypt-then-authenticate a string using the AES-256 block cipher and the HMAC algorithm (using the SHA-256 hash function).","title":"Encrypt/decrypt using block ciphers"},{"location":"block-cipher/#mcrypt","text":"The Mcrypt extension is based on the libmcrypt library. Unfortunately, at the time of writing, the project is dead, having been unmaintained for around 8 years, with the last release (version 2.5.8) having occurred in February 2007. Starting with PHP 7.1, the Mcrypt extension will be considered deprecated . For these reasons, we strongly suggest using only the Openssl adapter . Starting with zend-crypt 3.0, the Openssl adapter is the default (for example, by Zend\\Crypt\\FileCipher ), and all examples now only demonstrate that adapter. use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory('openssl', array('algo' => 'aes')); $blockCipher->setKey('encryption key'); $result = $blockCipher->encrypt('this is a secret message'); echo \"Encrypted text: $result\\n\"; The BlockCipher instance is initialized using a factory method with the name of the cipher adapter to use (e.g., openssl ) and the parameters to pass to the adapter (the AES algorithm). In order to encrypt a string, we need to specify an encryption key, which we do via the setKey() method. Encryption is performed with the encrypt() method. The output of encryption is a string, encoded in Base64 (default), containing the HMAC value, the IV vector, and the encrypted text. The encryption mode used is CBC (with a random IV by default), with the default HMAC hash algorithm of SHA256. The Openssl adapter encrypts using the PKCS#7 padding mechanism by default. You can specify a different padding method using a special adapter ( Zend\\Crypt\\Symmetric\\Padding ). The encryption and authentication keys used by BlockCipher are generated with the PBKDF2 algorithm, used as the key derivation function from the user's key specified using the setKey() method.","title":"Mcrypt"},{"location":"block-cipher/#key-size","text":"BlockCipher always attempts to use the longest key size for the specified cipher. For instance, for the AES algorithm it uses 256 bits, and for the Blowfish algorithm it uses 448 bits. You can change all the default settings by passing the values to the factory parameters. For instance, if you want to use the Blowfish algorithm, with the CFB mode and the HMAC SHA512 hash function, initialize the class as follows: use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory( 'openssl', [ 'algo' => 'blowfish', 'mode' => 'cfb', 'hash' => 'sha512' ] );","title":"Key size"},{"location":"block-cipher/#recommendation","text":"If you are not familiar with symmetric encryption techniques, we strongly suggest using the default values of the BlockCipher class. The default values are: AES algorithm, CBC mode, HMAC with SHA256, PKCS#7 padding. To decrypt a string we can use the decrypt() method. In order to successfully decrypt a string, we must configure the BlockCipher with the same parameters used during encryption. We can also initialize the BlockCipher manually without using the factory method; we can inject the symmetric cipher adapter directly via the constructor. For instance, we can rewrite the previous example as follows: use Zend\\Crypt\\BlockCipher; use Zend\\Crypt\\Symmetric\\Openssl; $blockCipher = new BlockCipher(new Openssl(['algo' => 'aes'])); $blockCipher->setKey('encryption key'); $result = $blockCipher->encrypt('this is a secret message'); echo \"Encrypted text: $result \\n\";","title":"Recommendation"},{"location":"block-cipher/#using-gcm-or-ccm-mode-from-php-71","text":"If you are using PHP 7.1+ you can choose the GCM or CCM mode for authenticated encryption with OpenSSL. These modes provide authenticated encryption by itself, without the usage of HMAC as described in the previous section. GCM is Galois/Counter Mode and CCM is Counter with CBC-MAC . For more information on the usage of this encryption modes in PHP we suggest to read this blog post . If you want to use the GCM or CCM mode with BlockCipher you can just specify the mode in the factory. For instance, the following is an example of aes-256-gcm encryption with OpenSSL: use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory( 'openssl', [ 'algo' => 'aes', 'mode' => 'gcm' ] ); And below is an example demonstrating the factory for aes-256-ccm algorithm: use Zend\\Crypt\\BlockCipher; $blockCipher = BlockCipher::factory( 'openssl', [ 'algo' => 'aes', 'mode' => 'ccm' ] );","title":"Using GCM or CCM mode from PHP 7.1+"},{"location":"block-cipher/#recommendation_1","text":"GCM mode is about 3x faster than CCM , we recommend using GCM unless you have requirements that dictate CCM.","title":"Recommendation"},{"location":"files/","text":"Encrypt and decrypt files Zend\\Crypt\\FileCipher implements file encryption and decryption using a symmetric cipher in CBC mode with the encrypt-then-authenticate approach, using HMAC to provide authentication (the same solution used by Zend\\Crypt\\BlockCipher component). Encrypting and decrypting a file is not an easy task, especially with large files. For instance, in CBC mode you must be sure to handle the IV correctly for each block. For large files, that means that you need to use a buffer and use the last block of the buffer as the new IV for the next encryption step. FileCipher uses a Zend\\Crypt\\Symmetric cipher to encrypt and decrypt a file. The default cipher is Zend\\Crypt\\Symmetric\\Openssl . The usage of this component is very simple; create an instance of FileCipher , specify the key, and you are ready to encrypt/decrypt any file: use Zend\\Crypt\\FileCipher; $fileCipher = new FileCipher; $fileCipher->setKey('encryption key'); // encryption if ($fileCipher->encrypt('path/to/file_to_encrypt', 'path/to/output')) { echo \"The file has been encrypted successfully\\n\"; } // decryption if ($fileCipher->decrypt('path/to/file_to_decrypt', 'path/to/output')) { echo \"The file has been decrypted successfully\\n\"; } By default, FileCipher uses the AES encryption algorithm (with a 256-bit key) and the SHA-256 hash algorithm to authenticate the data using the HMAC function. This component uses the PBKDF2 key derivation algorithm to generate the encryption key and the authentication key, for the HMAC, based on the key specified using the method setKey() . If you want to change the encryption algorithm, you can use the setCipherAlgorithm() function. For instance, you could specify the Blowfish encryption algorithm using setCipherAlgorithm('blowfish') . You can retrieve the list of all supported encryption algorithms in your environment using the function getCipherSupportedAlgorithms() . If you need to customize the cipher algorithm \u2014 for instance, to change the Padding mode \u2014 you can inject your Mcrypt object in the FileCipher using the setCipher() method. The only parameter of the cipher that you cannot change is the cipher mode, which is hard-coded to CBC. Output format The output of the encryption file is in binary format. We used this format to reduce impact on output size. If you encrypt a file using the FileCipher component, you will notice that the output file size is almost the same as the input size, with a few additional bytes to store the HMAC and the IV vector. The format of the output is the concatenation of the HMAC, the IV, and the encrypted file contents.","title":"Encrypting Files"},{"location":"files/#encrypt-and-decrypt-files","text":"Zend\\Crypt\\FileCipher implements file encryption and decryption using a symmetric cipher in CBC mode with the encrypt-then-authenticate approach, using HMAC to provide authentication (the same solution used by Zend\\Crypt\\BlockCipher component). Encrypting and decrypting a file is not an easy task, especially with large files. For instance, in CBC mode you must be sure to handle the IV correctly for each block. For large files, that means that you need to use a buffer and use the last block of the buffer as the new IV for the next encryption step. FileCipher uses a Zend\\Crypt\\Symmetric cipher to encrypt and decrypt a file. The default cipher is Zend\\Crypt\\Symmetric\\Openssl . The usage of this component is very simple; create an instance of FileCipher , specify the key, and you are ready to encrypt/decrypt any file: use Zend\\Crypt\\FileCipher; $fileCipher = new FileCipher; $fileCipher->setKey('encryption key'); // encryption if ($fileCipher->encrypt('path/to/file_to_encrypt', 'path/to/output')) { echo \"The file has been encrypted successfully\\n\"; } // decryption if ($fileCipher->decrypt('path/to/file_to_decrypt', 'path/to/output')) { echo \"The file has been decrypted successfully\\n\"; } By default, FileCipher uses the AES encryption algorithm (with a 256-bit key) and the SHA-256 hash algorithm to authenticate the data using the HMAC function. This component uses the PBKDF2 key derivation algorithm to generate the encryption key and the authentication key, for the HMAC, based on the key specified using the method setKey() . If you want to change the encryption algorithm, you can use the setCipherAlgorithm() function. For instance, you could specify the Blowfish encryption algorithm using setCipherAlgorithm('blowfish') . You can retrieve the list of all supported encryption algorithms in your environment using the function getCipherSupportedAlgorithms() . If you need to customize the cipher algorithm \u2014 for instance, to change the Padding mode \u2014 you can inject your Mcrypt object in the FileCipher using the setCipher() method. The only parameter of the cipher that you cannot change is the cipher mode, which is hard-coded to CBC.","title":"Encrypt and decrypt files"},{"location":"files/#output-format","text":"The output of the encryption file is in binary format. We used this format to reduce impact on output size. If you encrypt a file using the FileCipher component, you will notice that the output file size is almost the same as the input size, with a few additional bytes to store the HMAC and the IV vector. The format of the output is the concatenation of the HMAC, the IV, and the encrypted file contents.","title":"Output format"},{"location":"hybrid/","text":"Encrypt and decrypt using hybrid cryptosystem - Since 3.1.0 Hybrid is an encryption mode that uses symmetric and public key ciphers together. The approach takes advantage of public key cryptography for sharing keys and symmetric encryption speed for encrypting messages. Hybrid mode allows you to encrypt a message for one or more receivers, and can be used in multi-user scenarios where you wish to limit decryption to specific users. How it works Suppose we have two users: Alice and Bob . Alice wants to send a message to Bob using a hybrid cryptosystem, she needs to: Obtain Bob 's public key; Generates a random session key (one-time pad); Encrypts message using a symmetric cipher with the previous session key; Encrypts session key using the Bob 's public key; Sends both the encrypted message and encrypted session key to Bob . A schema of the encryption is reported in the image below: To decrypt the message, Bob needs to: Uses his private key to decrypt the session key; Uses this session key to decrypt the message. Example of usage In order to use the Zend\\Crypt\\Hybrid component, you need to have a keyring of public and private keys. To encrypt a message, use the following code: use Zend\\Crypt\\Hybrid; use Zend\\Crypt\\PublicKey\\RsaOptions; // Generate public and private key $rsaOptions = new RsaOptions([ 'pass_phrase' => 'test' ]); $rsaOptions->generateKeys([ 'private_key_bits' => 4096 ]); $publicKey = $rsaOptions->getPublicKey(); $privateKey = $rsaOptions->getPrivateKey(); $hybrid = new Hybrid(); $ciphertext = $hybrid->encrypt('message', $publicKey); $plaintext = $hybrid->decrypt($ciphertext, $privateKey); printf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\"); We generated the keys using the Zend\\Crypt\\PublicKey\\RsaOptions component. You can also use a PEM string for the keys. If you use a string for the private key, you need to pass the pass phrase to use when decrypting, if present, like in the following example: use Zend\\Crypt\\Hybrid; use Zend\\Crypt\\PublicKey\\RsaOptions; // Generate public and private key $rsaOptions = new RsaOptions([ 'pass_phrase' => 'test' ]); $rsaOptions->generateKeys([ 'private_key_bits' => 4096 ]); // Strings in PEM format $publicKey = $rsaOptions->getPublicKey()->toString(); $privateKey = $rsaOptions->getPrivateKey()->toString(); $hybrid = new Hybrid(); $ciphertext = $hybrid->encrypt('message', $publicKey); $plaintext = $hybrid->decrypt($ciphertext, $privateKey, 'test'); // pass-phrase printf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\"); The Hybrid component uses Zend\\Crypt\\BlockCipher for the symmetric cipher and Zend\\Crypt\\Rsa for the public-key cipher. Encrypt with multiple keys The Zend\\Crypt\\Hybrid component can be used to encrypt a message for multiple users, using a keyring of identifiers and public keys. This keyring can be specified using an array of [ 'id' => 'publickey' ] , where publickey can be a string (PEM) or an instance of Zend\\Crypt\\PublicKey\\Rsa\\PublicKey . The id can be any string, for example, a receipient email address. The following details encryption using a keyring with 4 keys: use Zend\\Crypt\\Hybrid; use Zend\\Crypt\\PublicKey\\RsaOptions; $publicKeys = []; $privateKeys = []; for ($id = 0; $id < 4; $id++) { $rsaOptions = new RsaOptions([ 'pass_phrase' => \"test-$id\" ]); $rsaOptions->generateKeys([ 'private_key_bits' => 4096 ]); $publicKeys[$id] = $rsaOptions->getPublicKey(); $privateKeys[$id] = $rsaOptions->getPrivateKey(); } $hybrid = new Hybrid(); $encrypted = $hybrid->encrypt('message', $publicKeys); for ($id = 0; $id < 4; $id++) { $plaintext = $hybrid->decrypt($encrypted, $privateKeys[$id], null, $id); printf($plaintext === 'message' ? \"Success on %d\\n\" : \"Error on %d\\n\", $id); }","title":"Hybrid Cryptosystem"},{"location":"hybrid/#encrypt-and-decrypt-using-hybrid-cryptosystem-since-310","text":"Hybrid is an encryption mode that uses symmetric and public key ciphers together. The approach takes advantage of public key cryptography for sharing keys and symmetric encryption speed for encrypting messages. Hybrid mode allows you to encrypt a message for one or more receivers, and can be used in multi-user scenarios where you wish to limit decryption to specific users.","title":"Encrypt and decrypt using hybrid cryptosystem - Since 3.1.0"},{"location":"hybrid/#how-it-works","text":"Suppose we have two users: Alice and Bob . Alice wants to send a message to Bob using a hybrid cryptosystem, she needs to: Obtain Bob 's public key; Generates a random session key (one-time pad); Encrypts message using a symmetric cipher with the previous session key; Encrypts session key using the Bob 's public key; Sends both the encrypted message and encrypted session key to Bob . A schema of the encryption is reported in the image below: To decrypt the message, Bob needs to: Uses his private key to decrypt the session key; Uses this session key to decrypt the message.","title":"How it works"},{"location":"hybrid/#example-of-usage","text":"In order to use the Zend\\Crypt\\Hybrid component, you need to have a keyring of public and private keys. To encrypt a message, use the following code: use Zend\\Crypt\\Hybrid; use Zend\\Crypt\\PublicKey\\RsaOptions; // Generate public and private key $rsaOptions = new RsaOptions([ 'pass_phrase' => 'test' ]); $rsaOptions->generateKeys([ 'private_key_bits' => 4096 ]); $publicKey = $rsaOptions->getPublicKey(); $privateKey = $rsaOptions->getPrivateKey(); $hybrid = new Hybrid(); $ciphertext = $hybrid->encrypt('message', $publicKey); $plaintext = $hybrid->decrypt($ciphertext, $privateKey); printf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\"); We generated the keys using the Zend\\Crypt\\PublicKey\\RsaOptions component. You can also use a PEM string for the keys. If you use a string for the private key, you need to pass the pass phrase to use when decrypting, if present, like in the following example: use Zend\\Crypt\\Hybrid; use Zend\\Crypt\\PublicKey\\RsaOptions; // Generate public and private key $rsaOptions = new RsaOptions([ 'pass_phrase' => 'test' ]); $rsaOptions->generateKeys([ 'private_key_bits' => 4096 ]); // Strings in PEM format $publicKey = $rsaOptions->getPublicKey()->toString(); $privateKey = $rsaOptions->getPrivateKey()->toString(); $hybrid = new Hybrid(); $ciphertext = $hybrid->encrypt('message', $publicKey); $plaintext = $hybrid->decrypt($ciphertext, $privateKey, 'test'); // pass-phrase printf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\"); The Hybrid component uses Zend\\Crypt\\BlockCipher for the symmetric cipher and Zend\\Crypt\\Rsa for the public-key cipher.","title":"Example of usage"},{"location":"hybrid/#encrypt-with-multiple-keys","text":"The Zend\\Crypt\\Hybrid component can be used to encrypt a message for multiple users, using a keyring of identifiers and public keys. This keyring can be specified using an array of [ 'id' => 'publickey' ] , where publickey can be a string (PEM) or an instance of Zend\\Crypt\\PublicKey\\Rsa\\PublicKey . The id can be any string, for example, a receipient email address. The following details encryption using a keyring with 4 keys: use Zend\\Crypt\\Hybrid; use Zend\\Crypt\\PublicKey\\RsaOptions; $publicKeys = []; $privateKeys = []; for ($id = 0; $id < 4; $id++) { $rsaOptions = new RsaOptions([ 'pass_phrase' => \"test-$id\" ]); $rsaOptions->generateKeys([ 'private_key_bits' => 4096 ]); $publicKeys[$id] = $rsaOptions->getPublicKey(); $privateKeys[$id] = $rsaOptions->getPrivateKey(); } $hybrid = new Hybrid(); $encrypted = $hybrid->encrypt('message', $publicKeys); for ($id = 0; $id < 4; $id++) { $plaintext = $hybrid->decrypt($encrypted, $privateKeys[$id], null, $id); printf($plaintext === 'message' ? \"Success on %d\\n\" : \"Error on %d\\n\", $id); }","title":"Encrypt with multiple keys"},{"location":"intro/","text":"Introduction zend-crypt provides support for several cryptographic tools, with the following features: encrypt-then-authenticate using symmetric ciphers (the authentication step is provided using HMAC); encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm); generate digital signature using public key algorithm (e.g. RSA algorithm); key exchange using the Diffie-Hellman method; key derivation function (e.g. using PBKDF2 algorithm); secure password hash (e.g. using bcrypt algorithm); generate hash values; and generate HMAC values. The main scope of this component is to offer an easy and secure way to protect and authenticate sensitive data in PHP. Because the use of cryptography is often complex, we recommend using the component only if you have background on this topic. For an introduction to cryptography, we suggest the following references: Dan Boneh, \"Cryptography course\" , Stanford University, Coursera; free online course N.Ferguson, B.Schneier, and T.Kohno, \"Cryptography Engineering\" , John Wiley & Sons (2010) B.Schneier \"Applied Cryptography\" , John Wiley & Sons (1996)","title":"Intro"},{"location":"intro/#introduction","text":"zend-crypt provides support for several cryptographic tools, with the following features: encrypt-then-authenticate using symmetric ciphers (the authentication step is provided using HMAC); encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm); generate digital signature using public key algorithm (e.g. RSA algorithm); key exchange using the Diffie-Hellman method; key derivation function (e.g. using PBKDF2 algorithm); secure password hash (e.g. using bcrypt algorithm); generate hash values; and generate HMAC values. The main scope of this component is to offer an easy and secure way to protect and authenticate sensitive data in PHP. Because the use of cryptography is often complex, we recommend using the component only if you have background on this topic. For an introduction to cryptography, we suggest the following references: Dan Boneh, \"Cryptography course\" , Stanford University, Coursera; free online course N.Ferguson, B.Schneier, and T.Kohno, \"Cryptography Engineering\" , John Wiley & Sons (2010) B.Schneier \"Applied Cryptography\" , John Wiley & Sons (1996)","title":"Introduction"},{"location":"key-derivation/","text":"Key derivation function In cryptography, a key derivation function (or KDF) derives one or more secret keys from a secret value such as a master key, or known information \u2014 such as a password or passphrase \u2014 using a pseudo-random function. For instance, a KDF function can be used to generate encryption or authentication keys from a user password. Zend\\Crypt\\Key\\Derivation implements a key derivation function using specific adapters. User passwords are not really suitable to be used as keys in cryptographic algorithms, since users normally choose keys they can write with a keyboard. These passwords use only 6 to 7 bits per character (or less). It is highly recommended always to use a KDF function to transform a user's password in a cryptographic key. The output of the following key derivation functions is a binary string. If you need to store the value in a database or a different persistent storage, we suggest converting it to Base64 format, using the base64_encode() function, or to hex format, using the bin2hex() function. Pbkdf2 adapter Pbkdf2 is a KDF that applies a pseudorandom function, such as a cryptographic hash, to the input password or passphrase along with a salt value and repeats the process many times to produce a derived key, which can then be used as a cryptographic key in subsequent operations. The added computational work makes password cracking much more difficult, and is known as key stretching . In the example below we demonstrate typical usage of the Pbkdf2 adapter. use Zend\\Crypt\\Key\\Derivation\\Pbkdf2; use Zend\\Math\\Rand; $pass = 'password'; $salt = Rand::getBytes(32, true); $key = Pbkdf2::calc('sha256', $pass, $salt, 10000, 32); printf (\"Original password: %s\\n\", $pass); printf (\"Derived key (hex): %s\\n\", bin2hex($key)); The Pbkdf2 adapter takes the password ( $pass ) and generates a binary key of 32 bytes. The syntax is calc($hash, $pass, $salt, $iterations, $length) where $hash is the name of the hash function to use, $pass is the password, $salt is a pseudo random value, $iterations is the number of iterations of the algorithm, and $length is the size of the key to be generated. We use the Rand::getBytes() function from the class Zend\\Math\\Rand to generate a random string of 32 bytes for the salt, using a strong generator (the true value means the usage of a cryptographically strong generator). The number of iterations is a very important parameter for the security of the algorithm; bigger values guarantee more security. There is no fixed value for the parameter because the number of iterations depends on CPU power. You should always choose a number of iterations that prevents brute force attacks. SaltedS2k adapter The SaltedS2k algorithm uses a hash function and a salt to generate a key based on a user's password. This algorithm doesn't use a parameter to specify the number of iterations, and for that reason it's considered less secure compared to Pbkdf2. We suggest using the SaltedS2k algorithm only if you really need it (for instance, due to hardware limitations). The following demonstrates usage of the SaltedS2k adapter to generate a 32 byte key. use Zend\\Crypt\\Key\\Derivation\\SaltedS2k; use Zend\\Math\\Rand; $pass = 'password'; $salt = Rand::getBytes(32, true); $key = SaltedS2k::calc('sha256', $pass, $salt, 32); printf (\"Original password: %s\\n\", $pass); printf (\"Derived key (hex): %s\\n\", bin2hex($key)); Scrypt adapter The scrypt algorithm uses the Salsa20/8 core algorithm and Pbkdf2-SHA256 to generate a key based on a user's password. This algorithm has been designed to be more secure against hardware brute-force attacks than alternative functions such as Pbkdf2 or bcrypt . The scrypt algorithm is based on the idea of memory-hard algorithms and sequential memory-hard functions. A memory-hard algorithm is an algorithm which asymptotically uses almost as many memory locations as it uses operations 1 . A natural way to reduce the advantage provided by an attacker\u2019s ability to construct highly parallel circuits is to increase the size of a single key derivation circuit \u2014 if a circuit is twice as large, only half as many copies can be placed on a given area of silicon \u2014 while still operating within the resources available to software implementations, including a powerful CPU and large amounts of RAM. \"From a test executed on modern (2009) hardware, if 5 seconds are spent computing a derived key, the cost of a hardware brute-force attack against scrypt is roughly 4000 times greater than the cost of a similar attack against bcrypt (to find the same password), and 20000 times greater than a similar attack against Pbkdf2.\" \u2014 Colin Percival (author of the scrypt algorithm) This algorithm uses 4 parameters to generate a key of 32 bytes: salt , a random string; N , the CPU cost; r , the memory cost; p , the parallelization cost. Following is a usage example for the Scrypt adapter: use Zend\\Crypt\\Key\\Derivation\\Scrypt; use Zend\\Math\\Rand; $pass = 'password'; $salt = Rand::getBytes(32, true); $key = Scrypt::calc($pass, $salt, 2048, 2, 1, 32); printf (\"Original password: %s\\n\", $pass); printf (\"Derived key (hex): %s\\n\", bin2hex($key)); Performance of the scrypt implementation The aim of the scrypt algorithm is to generate a secure derived key that prevents brute force attacks. Just like the other derivation functions, the more time (and memory) spent executing the algorithm, the more secure the derived key will be. Unfortunately a pure PHP implementation of the scrypt algorithm is very slow compared with the C implementation (this is always true, if you compare execution time of C with PHP). If you want use a faster scrypt algorithm, we suggest installing the PECL scrypt extension . The Scrypt adapter we provide is able to recognize if the PECL extension is loaded and will use it instead of the pure PHP implementation. Footnotes 1 See Colin Percival's slides on scrypt from BSDCan'09 .","title":"Key Derivation"},{"location":"key-derivation/#key-derivation-function","text":"In cryptography, a key derivation function (or KDF) derives one or more secret keys from a secret value such as a master key, or known information \u2014 such as a password or passphrase \u2014 using a pseudo-random function. For instance, a KDF function can be used to generate encryption or authentication keys from a user password. Zend\\Crypt\\Key\\Derivation implements a key derivation function using specific adapters. User passwords are not really suitable to be used as keys in cryptographic algorithms, since users normally choose keys they can write with a keyboard. These passwords use only 6 to 7 bits per character (or less). It is highly recommended always to use a KDF function to transform a user's password in a cryptographic key. The output of the following key derivation functions is a binary string. If you need to store the value in a database or a different persistent storage, we suggest converting it to Base64 format, using the base64_encode() function, or to hex format, using the bin2hex() function.","title":"Key derivation function"},{"location":"key-derivation/#pbkdf2-adapter","text":"Pbkdf2 is a KDF that applies a pseudorandom function, such as a cryptographic hash, to the input password or passphrase along with a salt value and repeats the process many times to produce a derived key, which can then be used as a cryptographic key in subsequent operations. The added computational work makes password cracking much more difficult, and is known as key stretching . In the example below we demonstrate typical usage of the Pbkdf2 adapter. use Zend\\Crypt\\Key\\Derivation\\Pbkdf2; use Zend\\Math\\Rand; $pass = 'password'; $salt = Rand::getBytes(32, true); $key = Pbkdf2::calc('sha256', $pass, $salt, 10000, 32); printf (\"Original password: %s\\n\", $pass); printf (\"Derived key (hex): %s\\n\", bin2hex($key)); The Pbkdf2 adapter takes the password ( $pass ) and generates a binary key of 32 bytes. The syntax is calc($hash, $pass, $salt, $iterations, $length) where $hash is the name of the hash function to use, $pass is the password, $salt is a pseudo random value, $iterations is the number of iterations of the algorithm, and $length is the size of the key to be generated. We use the Rand::getBytes() function from the class Zend\\Math\\Rand to generate a random string of 32 bytes for the salt, using a strong generator (the true value means the usage of a cryptographically strong generator). The number of iterations is a very important parameter for the security of the algorithm; bigger values guarantee more security. There is no fixed value for the parameter because the number of iterations depends on CPU power. You should always choose a number of iterations that prevents brute force attacks.","title":"Pbkdf2 adapter"},{"location":"key-derivation/#salteds2k-adapter","text":"The SaltedS2k algorithm uses a hash function and a salt to generate a key based on a user's password. This algorithm doesn't use a parameter to specify the number of iterations, and for that reason it's considered less secure compared to Pbkdf2. We suggest using the SaltedS2k algorithm only if you really need it (for instance, due to hardware limitations). The following demonstrates usage of the SaltedS2k adapter to generate a 32 byte key. use Zend\\Crypt\\Key\\Derivation\\SaltedS2k; use Zend\\Math\\Rand; $pass = 'password'; $salt = Rand::getBytes(32, true); $key = SaltedS2k::calc('sha256', $pass, $salt, 32); printf (\"Original password: %s\\n\", $pass); printf (\"Derived key (hex): %s\\n\", bin2hex($key));","title":"SaltedS2k adapter"},{"location":"key-derivation/#scrypt-adapter","text":"The scrypt algorithm uses the Salsa20/8 core algorithm and Pbkdf2-SHA256 to generate a key based on a user's password. This algorithm has been designed to be more secure against hardware brute-force attacks than alternative functions such as Pbkdf2 or bcrypt . The scrypt algorithm is based on the idea of memory-hard algorithms and sequential memory-hard functions. A memory-hard algorithm is an algorithm which asymptotically uses almost as many memory locations as it uses operations 1 . A natural way to reduce the advantage provided by an attacker\u2019s ability to construct highly parallel circuits is to increase the size of a single key derivation circuit \u2014 if a circuit is twice as large, only half as many copies can be placed on a given area of silicon \u2014 while still operating within the resources available to software implementations, including a powerful CPU and large amounts of RAM. \"From a test executed on modern (2009) hardware, if 5 seconds are spent computing a derived key, the cost of a hardware brute-force attack against scrypt is roughly 4000 times greater than the cost of a similar attack against bcrypt (to find the same password), and 20000 times greater than a similar attack against Pbkdf2.\" \u2014 Colin Percival (author of the scrypt algorithm) This algorithm uses 4 parameters to generate a key of 32 bytes: salt , a random string; N , the CPU cost; r , the memory cost; p , the parallelization cost. Following is a usage example for the Scrypt adapter: use Zend\\Crypt\\Key\\Derivation\\Scrypt; use Zend\\Math\\Rand; $pass = 'password'; $salt = Rand::getBytes(32, true); $key = Scrypt::calc($pass, $salt, 2048, 2, 1, 32); printf (\"Original password: %s\\n\", $pass); printf (\"Derived key (hex): %s\\n\", bin2hex($key));","title":"Scrypt adapter"},{"location":"key-derivation/#footnotes","text":"1 See Colin Percival's slides on scrypt from BSDCan'09 .","title":"Footnotes"},{"location":"password/","text":"Password In the Zend\\Crypt\\Password namespace you will find a number of password formats supported by the zend-crypt component. These currently include: bcrypt Apache (htpasswd) If you need to choose a password format to store a user\u2019s password, we suggest using the bcrypt algorithm, as it is considered secure against brute forcing attacks (see details below). Bcrypt The bcrypt algorithm is a hashing algorithm that is widely used and recommended by the security community to store user passwords in a secure way. Classic hashing mechanisms like MD5 or SHA, with or without a salt value, are not considered secure anymore ( read this post to understand why ). The security of bcrypt is related to the speed of the algorithm. Bcrypt is very slow, and can take up to a second to generate a hash value. That means a brute force attack is impossible to execute, due to the amount of time that required. Bcrypt uses a cost parameter that specify the number of cycles to use in the algorithm. Increasing this number the algorithm will spend more time to generate the hash output. The cost parameter is represented by an integer value between 4 to 31. The default cost value of Zend\\Crypt\\Password\\Bcrypt is 10, requiring around 0.07s using a CPU Intel i5 at 3.3Ghz (the cost parameter is a relative value according to the speed of the CPU used). Starting with version 2.3.0, we changed the default value of the cost parameter from 14 to 10, in an effort to reduce denial-of-service attacks due to too high computational time requirements. (Read this article on aggressive password stretching for more information). If you want to change the cost parameter of the bcrypt algorithm, you can use the setCost() method. Please note, if you change the cost parameter, the resulting hash will be different. However, This will not affect the verification process of the algorithm, therefore not breaking the password hashes you already have stored; Bcrypt reads the cost parameter from the hash value during password authentication. All of the parts needed to verify the hash are present in the hash itself,, separated with $ \u2019s; first the algorithm, then the cost, the salt, and then finally the hash. The example below demonstrates using the bcrypt algorithm to store a user\u2019s password: use Zend\\Crypt\\Password\\Bcrypt; $bcrypt = new Bcrypt(); $securePass = $bcrypt->create('user password'); The output of the create() method is the hash of the password. This value can then be stored in a repository like a database (the output is a string of 60 bytes). Bcrypt truncates input > 72 bytes The input string of the bcrypt algorithm is limited to 72 bytes. If you use a string with a length more than this limit, bcrypt will consider only the first 72 bytes. If you need to use a longer string, you should pre-hash it. We provide the class Zend\\Crypt\\Password\\BcryptSha for performing password pre-hashing of hash input > 72 bytes. To verify if a given password is valid against a bcrypt value you can use the verify() method. The example below demonstrates verification: use Zend\\Crypt\\Password\\Bcrypt; $bcrypt = new Bcrypt(); $securePass = 'the stored bcrypt value'; $password = 'the password to check'; if ($bcrypt->verify($password, $securePass)) { echo \"The password is correct! \\n\"; } else { echo \"The password is NOT correct.\\n\"; } Bcrypt also uses a salt value to improve the randomness of the algorithm. By default, Zend\\Crypt\\Password\\Bcrypt generates a random salt for each hash. If you want to specify a preselected salt you can use the setSalt() method. We also provide a getSalt() method to retrieve the salt specified by the user. The salt and the cost parameter can be also specified during the constructor of the class, as demonstrated below: use Zend\\Crypt\\Password\\Bcrypt; $bcrypt = new Bcrypt([ 'salt' => 'random value', 'cost' => 11 ]); Version 3.0 Starting with version 3.0, we now use the password_hash() and ` password_verify() functions introduced in PHP 5.5 to generate bcrypt hash values. We provide backwards compatibility tests to ensure that any hashes generated with version 2 releases can still be validated under version 3. Apache Zend\\Crypt\\Password\\Apache supports all the password formats used by Apache (htpasswd). These formats include: CRYPT, which uses the traditional Unix crypt(3) function with a randomly-generated 32-bit salt (only 12 bits used) and the first 8 characters of the password; SHA1, \u201c{SHA}\u201d + Base64-encoded SHA-1 digest of the password; MD5, \u201c$apr1$\u201d + the result of an Apache-specific algorithm using an iterated (1,000 times) MD5 digest of various combinations of a random 32-bit salt and the password. Digest, the MD5 hash of the string user:realm:password as a 32-character string of hexadecimal digits. realm is the Authorization Realm argument to the AuthName directive in httpd.conf . In order to specify the format of the Apache\u2019s password, use the setFormat() method. An example with all the formats usage is demonstrated below: use Zend\\Crypt\\Password\\Apache; $apache = new Apache(); $apache->setFormat('crypt'); printf (\"CRYPT output: %s\\n\", $apache->create('password')); $apache->setFormat('sha1'); printf (\"SHA1 output: %s\\n\", $apache->create('password')); $apache->setFormat('md5'); printf (\"MD5 output: %s\\n\", $apache->create('password')); $apache->setFormat('digest'); $apache->setUserName('enrico'); $apache->setAuthName('test'); printf (\"Digest output: %s\\n\", $apache->create('password')); You can also specify the format of the password during the constructor of the class: use Zend\\Crypt\\Password\\Apache; $apache = new Apache([ 'format' => 'md5' ]); Other possible parameters to pass in the constructor are username and authname , for the digest format.","title":"Passwords"},{"location":"password/#password","text":"In the Zend\\Crypt\\Password namespace you will find a number of password formats supported by the zend-crypt component. These currently include: bcrypt Apache (htpasswd) If you need to choose a password format to store a user\u2019s password, we suggest using the bcrypt algorithm, as it is considered secure against brute forcing attacks (see details below).","title":"Password"},{"location":"password/#bcrypt","text":"The bcrypt algorithm is a hashing algorithm that is widely used and recommended by the security community to store user passwords in a secure way. Classic hashing mechanisms like MD5 or SHA, with or without a salt value, are not considered secure anymore ( read this post to understand why ). The security of bcrypt is related to the speed of the algorithm. Bcrypt is very slow, and can take up to a second to generate a hash value. That means a brute force attack is impossible to execute, due to the amount of time that required. Bcrypt uses a cost parameter that specify the number of cycles to use in the algorithm. Increasing this number the algorithm will spend more time to generate the hash output. The cost parameter is represented by an integer value between 4 to 31. The default cost value of Zend\\Crypt\\Password\\Bcrypt is 10, requiring around 0.07s using a CPU Intel i5 at 3.3Ghz (the cost parameter is a relative value according to the speed of the CPU used). Starting with version 2.3.0, we changed the default value of the cost parameter from 14 to 10, in an effort to reduce denial-of-service attacks due to too high computational time requirements. (Read this article on aggressive password stretching for more information). If you want to change the cost parameter of the bcrypt algorithm, you can use the setCost() method. Please note, if you change the cost parameter, the resulting hash will be different. However, This will not affect the verification process of the algorithm, therefore not breaking the password hashes you already have stored; Bcrypt reads the cost parameter from the hash value during password authentication. All of the parts needed to verify the hash are present in the hash itself,, separated with $ \u2019s; first the algorithm, then the cost, the salt, and then finally the hash. The example below demonstrates using the bcrypt algorithm to store a user\u2019s password: use Zend\\Crypt\\Password\\Bcrypt; $bcrypt = new Bcrypt(); $securePass = $bcrypt->create('user password'); The output of the create() method is the hash of the password. This value can then be stored in a repository like a database (the output is a string of 60 bytes).","title":"Bcrypt"},{"location":"password/#apache","text":"Zend\\Crypt\\Password\\Apache supports all the password formats used by Apache (htpasswd). These formats include: CRYPT, which uses the traditional Unix crypt(3) function with a randomly-generated 32-bit salt (only 12 bits used) and the first 8 characters of the password; SHA1, \u201c{SHA}\u201d + Base64-encoded SHA-1 digest of the password; MD5, \u201c$apr1$\u201d + the result of an Apache-specific algorithm using an iterated (1,000 times) MD5 digest of various combinations of a random 32-bit salt and the password. Digest, the MD5 hash of the string user:realm:password as a 32-character string of hexadecimal digits. realm is the Authorization Realm argument to the AuthName directive in httpd.conf . In order to specify the format of the Apache\u2019s password, use the setFormat() method. An example with all the formats usage is demonstrated below: use Zend\\Crypt\\Password\\Apache; $apache = new Apache(); $apache->setFormat('crypt'); printf (\"CRYPT output: %s\\n\", $apache->create('password')); $apache->setFormat('sha1'); printf (\"SHA1 output: %s\\n\", $apache->create('password')); $apache->setFormat('md5'); printf (\"MD5 output: %s\\n\", $apache->create('password')); $apache->setFormat('digest'); $apache->setUserName('enrico'); $apache->setAuthName('test'); printf (\"Digest output: %s\\n\", $apache->create('password')); You can also specify the format of the password during the constructor of the class: use Zend\\Crypt\\Password\\Apache; $apache = new Apache([ 'format' => 'md5' ]); Other possible parameters to pass in the constructor are username and authname , for the digest format.","title":"Apache"},{"location":"public-key/","text":"Public key cryptography Public-key cryptography refers to a cryptographic system requiring two separate keys, one of which is secret and one of which is public. Although different, the two parts of the key pair are mathematically linked. One key locks or encrypts the plaintext, and the other unlocks or decrypts the cyphertext. Neither key can perform both functions. One of these keys is published or public, while the other is kept private. In zend-crypt, we implement two public key algorithms: Diffie-Hellman key exchange, and RSA . Diffie-Hellman The Diffie-Hellman algorithm is a specific method of exchanging cryptographic keys. It is one of the earliest practical examples of key exchange implemented within the field of cryptography. The Diffie\u2013Hellman key exchange method allows two parties that have no prior knowledge of each other to jointly establish a shared secret key over an insecure communications channel. This key can then be used to encrypt subsequent communications using a symmetric key cipher. The diagram of operation of the Diffie-Hellman algorithm can be defined by the following picture (taken from the Diffie-Hellman Wikipedia page): The schema's colors represent the parameters of the algorithm. Below is an example demonstrating usage of Zend\\Crypt\\PublicKey\\DiffieHellman : use Zend\\Crypt\\PublicKey\\DiffieHellman; $aliceOptions = [ 'prime' => '155172898181473697471232257763715539915724801966915404479707795314057629378541917580651227' . '423698188993727816152646631438561595825688188889951272158842675419950341258706556549803580' . '104870537681476726513255747040765857479291291572334510643245094715007229621094194349783925' . '984760375594985848253359305585439638443', 'generator'=> '2', 'private' => '992093140665725952364085695919679885571412495614942674862518080355353963322786201435363176' . '813127128916726230726309951803243888416814918577455156967890911274095150092503589658166661' . '463420498381785213791321533481399080168191962194483101070726325157493390557981225386151351' . '04828702523796951800575031871051678091', ]; $bobOptions = [ 'prime' => $aliceOptions['prime'], 'generator'=> '2', 'private' => '334117357926395586257336357178925636125481806504021611510774783148414637079488997861035889' . '123256347304105519467727528801778689728169635518217403867000760342134081539246925625431179' . '634647331566005454845108330724270034742070646507148310833044977371603820970833568760781462' . '31616972608703322302585471319261275664', ); $alice = new DiffieHellman( $aliceOptions['prime'], $aliceOptions['generator'], $aliceOptions['private'] ); $bob = new DiffieHellman( $bobOptions['prime'], $bobOptions['generator'], $bobOptions['private'] ); $alice->generateKeys(); $bob->generateKeys(); $aliceSecretKey = $alice->computeSecretKey( $bob->getPublicKey(DiffieHellman::FORMAT_BINARY), DiffieHellman::FORMAT_BINARY, DiffieHellman::FORMAT_BINARY ); $bobSecretKey = $bob->computeSecretKey( $alice->getPublicKey(DiffieHellman::FORMAT_BINARY), DiffieHellman::FORMAT_BINARY, DiffieHellman::FORMAT_BINARY ); if ($aliceSecretKey !== $bobSecretKey) { echo \"ERROR!\\n\"; } else { printf(\"The secret key is: %s\\n\", base64_encode($aliceSecretKey)); } The parameters of the Diffie-Hellman class are: a prime number (p), a generator (g) that is a primitive root mod p, and a private integer number. The security of the Diffie-Hellman exchange algorithm is related to the choice of these parameters. To know how to choose secure numbers you can read the RFC 3526 document. Openssl The Zend\\Crypt\\PublicKey\\DiffieHellman class by default uses the OpenSSL extension to generate the parameters. If you don't want to use the OpenSSL library, call DiffieHelmman::useOpensslExtension(false) . RSA RSA is an algorithm for public-key cryptography that is based on the presumed difficulty of factoring large integers, known as the factoring problem . A user of RSA creates and then publishes the product of two large prime numbers, along with an auxiliary value, as their public key. The prime factors must be kept secret. Anyone can use the public key to encrypt a message, but with currently published methods, if the public key is large enough, only someone with knowledge of the prime factors can feasibly decode the message. Whether breaking RSA encryption is as hard as factoring is an open question. The RSA algorithm can be used to encrypt/decrypt messages, and also to provide authenticity and integrity by generating a digital signature of a message. Suppose that Alice wants to send an encrypted message to Bob. Alice must use the public key of Bob to encrypt the message. Bob can decrypt the message using his private key. Because Bob is the only one that can access his private key, he is the only one that can decrypt the message. If Alice wants to provide authenticity and integrity of a message to Bob she can use her private key to sign the message. Bob can check the correctness of the digital signature using the public key of Alice. Alice can provide encryption, authenticity, and integrity of a message to Bob using the previous schemas in sequence, applying the encryption first and the digital signature after. Below are examples of usage of the Zend\\Crypt\\PublicKey\\Rsa class in order to: generate a public key and a private key; encrypt/decrypt a string; generate a digital signature of a file. Generate a public key and a private key In order to generate a public and private key, use the following code: use Zend\\Crypt\\PublicKey\\RsaOptions; $rsaOptions = new RsaOptions([ 'pass_phrase' => 'test' ]); $rsaOptions->generateKeys([ 'private_key_bits' => 2048, ]); file_put_contents('private_key.pem', $rsaOptions->getPrivateKey()); file_put_contents('public_key.pub', $rsaOptions->getPublicKey()); This example generates a 2048-bit public and private key, storing the keys in two separate files, private_key.pem for the private key and public_key.pub for the public key. You can also generate the public and private key using OpenSSL from the command line (Unix style syntax): $ ssh-keygen -t rsa Encrypt and decrypt a string Below is an example demonstrating encryption and decryption of a string using the RSA algorithm. You can encrypt only small strings. The maximum size of encryption is given by the length of the public/private key - 88 bits. For instance, if we use a size of 2048 bit you can encrypt a string with a maximum size of 1960 bit (245 characters). This limitation is related to the OpenSSL implementation for a security reason related to the nature of the RSA algorithm. The normal application of public key encryption algorithm is to store a key or a hash of the data you want to encrypt or sign. A hash is typically 128-256 bits (the PHP sha1() function returns a 160 bit hash). An AES encryption key is 128 to 256 bits. Either will comfortably fit inside a single RSA encryption. use Zend\\Crypt\\PublicKey\\Rsa; $rsa = Rsa::factory([ 'public_key' => 'public_key.pub', 'private_key' => 'private_key.pem', 'pass_phrase' => 'test', 'binary_output' => false, ]); $text = 'This is the message to encrypt'; $encrypt = $rsa->encrypt($text); printf(\"Encrypted message:\\n%s\\n\", $encrypt); $decrypt = $rsa->decrypt($encrypt); if ($text !== $decrypt) { echo \"ERROR\\n\"; } else { echo \"Encryption and decryption performed successfully!\\n\"; } Generate a digital signature of a file Below is an example demonstrating generation of a digital file signature. use Zend\\Crypt\\PublicKey\\Rsa; $rsa = Rsa::factory([ 'private_key' => 'path/to/private_key', 'pass_phrase' => 'passphrase of the private key', 'binary_output' => false, ]); $file = file_get_contents('path/file/to/sign'); $signature = $rsa->sign($file, $rsa->getOptions()->getPrivateKey()); $verify = $rsa->verify($file, $signature, $rsa->getOptions()->getPublicKey()); if ($verify) { echo \"The signature is OK\\n\"; file_put_contents($filename . '.sig', $signature); echo \"Signature save in $filename.sig\\n\"; } else { echo \"The signature is not valid!\\n\"; } In this example, we used the Base64 format to encode the digital signature of the file ( binary_output is false). Openssl The implementation of the Zend\\Crypt\\PublicKey\\Rsa algorithm uses PHP's OpenSSL extension.","title":"Public Key Cryptography"},{"location":"public-key/#public-key-cryptography","text":"Public-key cryptography refers to a cryptographic system requiring two separate keys, one of which is secret and one of which is public. Although different, the two parts of the key pair are mathematically linked. One key locks or encrypts the plaintext, and the other unlocks or decrypts the cyphertext. Neither key can perform both functions. One of these keys is published or public, while the other is kept private. In zend-crypt, we implement two public key algorithms: Diffie-Hellman key exchange, and RSA .","title":"Public key cryptography"},{"location":"public-key/#diffie-hellman","text":"The Diffie-Hellman algorithm is a specific method of exchanging cryptographic keys. It is one of the earliest practical examples of key exchange implemented within the field of cryptography. The Diffie\u2013Hellman key exchange method allows two parties that have no prior knowledge of each other to jointly establish a shared secret key over an insecure communications channel. This key can then be used to encrypt subsequent communications using a symmetric key cipher. The diagram of operation of the Diffie-Hellman algorithm can be defined by the following picture (taken from the Diffie-Hellman Wikipedia page): The schema's colors represent the parameters of the algorithm. Below is an example demonstrating usage of Zend\\Crypt\\PublicKey\\DiffieHellman : use Zend\\Crypt\\PublicKey\\DiffieHellman; $aliceOptions = [ 'prime' => '155172898181473697471232257763715539915724801966915404479707795314057629378541917580651227' . '423698188993727816152646631438561595825688188889951272158842675419950341258706556549803580' . '104870537681476726513255747040765857479291291572334510643245094715007229621094194349783925' . '984760375594985848253359305585439638443', 'generator'=> '2', 'private' => '992093140665725952364085695919679885571412495614942674862518080355353963322786201435363176' . '813127128916726230726309951803243888416814918577455156967890911274095150092503589658166661' . '463420498381785213791321533481399080168191962194483101070726325157493390557981225386151351' . '04828702523796951800575031871051678091', ]; $bobOptions = [ 'prime' => $aliceOptions['prime'], 'generator'=> '2', 'private' => '334117357926395586257336357178925636125481806504021611510774783148414637079488997861035889' . '123256347304105519467727528801778689728169635518217403867000760342134081539246925625431179' . '634647331566005454845108330724270034742070646507148310833044977371603820970833568760781462' . '31616972608703322302585471319261275664', ); $alice = new DiffieHellman( $aliceOptions['prime'], $aliceOptions['generator'], $aliceOptions['private'] ); $bob = new DiffieHellman( $bobOptions['prime'], $bobOptions['generator'], $bobOptions['private'] ); $alice->generateKeys(); $bob->generateKeys(); $aliceSecretKey = $alice->computeSecretKey( $bob->getPublicKey(DiffieHellman::FORMAT_BINARY), DiffieHellman::FORMAT_BINARY, DiffieHellman::FORMAT_BINARY ); $bobSecretKey = $bob->computeSecretKey( $alice->getPublicKey(DiffieHellman::FORMAT_BINARY), DiffieHellman::FORMAT_BINARY, DiffieHellman::FORMAT_BINARY ); if ($aliceSecretKey !== $bobSecretKey) { echo \"ERROR!\\n\"; } else { printf(\"The secret key is: %s\\n\", base64_encode($aliceSecretKey)); } The parameters of the Diffie-Hellman class are: a prime number (p), a generator (g) that is a primitive root mod p, and a private integer number. The security of the Diffie-Hellman exchange algorithm is related to the choice of these parameters. To know how to choose secure numbers you can read the RFC 3526 document.","title":"Diffie-Hellman"},{"location":"public-key/#rsa","text":"RSA is an algorithm for public-key cryptography that is based on the presumed difficulty of factoring large integers, known as the factoring problem . A user of RSA creates and then publishes the product of two large prime numbers, along with an auxiliary value, as their public key. The prime factors must be kept secret. Anyone can use the public key to encrypt a message, but with currently published methods, if the public key is large enough, only someone with knowledge of the prime factors can feasibly decode the message. Whether breaking RSA encryption is as hard as factoring is an open question. The RSA algorithm can be used to encrypt/decrypt messages, and also to provide authenticity and integrity by generating a digital signature of a message. Suppose that Alice wants to send an encrypted message to Bob. Alice must use the public key of Bob to encrypt the message. Bob can decrypt the message using his private key. Because Bob is the only one that can access his private key, he is the only one that can decrypt the message. If Alice wants to provide authenticity and integrity of a message to Bob she can use her private key to sign the message. Bob can check the correctness of the digital signature using the public key of Alice. Alice can provide encryption, authenticity, and integrity of a message to Bob using the previous schemas in sequence, applying the encryption first and the digital signature after. Below are examples of usage of the Zend\\Crypt\\PublicKey\\Rsa class in order to: generate a public key and a private key; encrypt/decrypt a string; generate a digital signature of a file.","title":"RSA"},{"location":"public-key/#openssl","text":"The implementation of the Zend\\Crypt\\PublicKey\\Rsa algorithm uses PHP's OpenSSL extension.","title":"Openssl"}]}